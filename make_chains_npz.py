#!/usr/bin/env python3

"""
make_chains.py
Assembles all chains based on a connectivity graph, and a maximum meanrank
In addition, for every chain, the exact overlap RMSD is computed from the preatom and postatom coordinates,
 and the l-RMSD toward the bound form as well

Argument 1: connectivity graph (in NPZ format), as generated by connect.py + json2numpy
            the connectivity graph contains numpy arrays interactions-0, interactions-1 etc.
            interactions-0 is between frag1 and frag2, interactions-1 between frag2 and frag3, etc.
            These Numpy arrays are connections A->B where A and B describe ATTRACT ranks *counting from zero*
Argument 2: maximum (geometric) meanrank of the chains
Argument 3 - (3 + nfrag -1 ): preatom coordinates for each fragment
Argument (3 + nfrag) - (3 + 2 * nfrag  - 1): postatom coordinates for each fragment
Argument (3 + 2 * nfrag) - (3 + 3 * nfrag  - 1): l-RMSD for each fragment

Copyright 2015-2017 Sjoerd de Vries, Isaure Chauvot de Beauchene, TUM
"""

import sys, json
import numpy as np
from math import log
import sys
from collections import OrderedDict

def write_chain(ranks, sum_overlap_msds, meanrank):
    '''  write the chain in output file'''
    global count
    lrms, o = "", ""
    lr = []
    if lrmsds is not None:
        for pose, rank in enumerate(ranks):
            lr.append(lrmsds[pose][rank+1])
        lrms = np.sqrt(sum([v*v for v in lr])/len(lr))
        lrms = "%.3f" % lrms
    o = np.sqrt(sum_overlap_msds / (len(ranks) - 1) )
    o = "%.3f" % o
    meanrank = "%.3f" % meanrank
    print(lrms, meanrank, o, end=' ')
    for i in ranks: print(i+1, end=' ')
    for l in lr: print(l, end=' ')
    print()
    count += 1

def walk(interactions_dict, pos, curr, ranks, sum_overlap_msds, curr_meanrank):
    '''
    Do the chain building, iteratively.
      pos = position of fragment in the chain
      curr = pose rank in the pool for the considered fragment
      ranks = which pose rank taken for each of the upstream fragments
    '''
    new_ranks = ranks + (curr,)
    curr_meanrank += log(curr+1)
    # if the chain already has a too high score:
    if curr_meanrank > meanrank_threshold: return
    overlap_msd = 0 # msd of the overlapping parts in the chain
                    # (how well the poses fit spatially together)
    if pos > 0:
        pre = preatoms[pos-1][ranks[-1]]
        post = postatoms[pos][curr]
        d = post - pre
        overlap_msd = (d*d).sum()/pre.shape[0]
    new_sum_overlap_msds = sum_overlap_msds + overlap_msd
    if pos == nfrag - 1: # if we reached the end of the chain
        meanrank = np.exp(curr_meanrank/nfrag)
        write_chain(new_ranks, new_sum_overlap_msds, meanrank)
        return
    for target in interactions_dict[pos][curr]:
        # take the next connected pose to the current pose
        walk(interactions_dict, pos+1, target, new_ranks, new_sum_overlap_msds, curr_meanrank)

if __name__ == "__main__":
    # The npz file contains the connectivity graph
    # This is the output either of connect.py|json2numpy.py,
    # or of meanrank_filter.py applied to the output of connect.py.
    # It contains the list of connected poses
    # for each pair of consecutive fragments
    tree = np.load(sys.argv[1])

    # Nb of fragments in the chain
    nfrag = tree["nfrags"]
    try:
        i = int((len(sys.argv) - 3)//nfrag)
    except ImportError:
        print("wrong number of arguments")

    # User-defined maximal score/energy for the whole chain
    max_meanrank = float(sys.argv[2])
    meanrank_threshold = log(max_meanrank) * nfrag

    # np.array of poses coordinates
    preatoms, postatoms = sys.argv[3:nfrag+3], sys.argv[nfrag+3:2*nfrag+3]
    def load_atoms(atomsf):
        result = []
        for n, f in enumerate(atomsf):
            if f in atomsf[:n]:
                result.append(result[atomsf.index(f)])
            else:
                result.append(np.load(f))
        return result
    postatoms = load_atoms(postatoms)
    preatoms = load_atoms(preatoms)
    for arr in (preatoms, postatoms):        
        for anr, a in enumerate(arr):
            if len(a.shape) == 3 and a.shape[-1] == 3:
                a = a.reshape(len(a), -1)
            ncoor = a.shape[1] // 3
            arr[anr] = a.reshape(a.shape[0], ncoor, 3)

    # extract the ligand-rmsd of the poses computed by ATTRACT
    # This is not used in the chain-building, only written in
    # the output file
    lrmsds = None
    if len(sys.argv) > 2*nfrag+4:
        lrmsds = []
        for f in sys.argv[2*nfrag+3:3*nfrag+3]:
            lrmsd = {}
            lnr = 0
            for l in open(f):
                lnr += 1
                ll = l.split()
                if len(ll) != 2: continue
                k = ll[0]
                if k == "l-RMSD": k = lnr
                else: k = int(k)
                value = float(ll[1])
                lrmsd[k] = value
            lrmsds.append(lrmsd)

    # for each frag, interactions = list of the connected downstream poses
    # extracted from the tree
    interactions = [ tree["interactions-%i"%i] for i in range(nfrag-1)]
    for i in range(nfrag):
        assert len(preatoms[i]) == len(postatoms[i]), (i+1, len(preatoms[i]), len(postatoms[i]))
        if lrmsds:
            assert len(lrmsds[i]) == len(preatoms[i]), (i+1, len(lrmsds[i]), len(preatoms[i]))
    for i, inter in enumerate(interactions):
        frag1, frag2 = i, i+1
        preatoms1, preatoms2 = preatoms[frag1], preatoms[frag2]
        postatoms1, postatoms2 = postatoms[frag1], postatoms[frag2]
        assert np.max(inter[:,0]) < len(postatoms1), np.max(inter[:,0])
        assert np.max(inter[:,1]) < len(postatoms2), np.max(inter[:,1])

    interactions_dict = [OrderedDict() for l in range(nfrag-1)]
    for cnr, tinter in enumerate(interactions):
        inter_dict = interactions_dict[cnr]
        for source, target in tinter:
            #(source, target) is a pair of connected poses.
            # Store the connections with the next fragment.
            # Count number of connections with previous fragment.
            if source not in inter_dict: inter_dict[source] = []
            inter_dict[source].append(target)

    count = 0 # count number of chains
    header="#header <mean (root-mean-sq) ligand rmsd> <mean (geometric mean) rank>  <rms-overlap-rmsd> <ranks> <ligand rmsds>"
    if lrmsds is None:
        header="#header <mean (geometric mean) rank>  <rms-overlap-rmsd> <ranks>"
    print(header)
    for ff in interactions_dict[0]:
        walk(interactions_dict, 0, ff, (), 0, 0)

    print(count, file=sys.stderr)
