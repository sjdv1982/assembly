#!/usr/bin/env python3

"""
count_chains_npz.py (adapted from make_chains.py)
Assembles all chains based on a connectivity graph

Argument 1: connectivity graph (in NPZ format), as generated by connect.py + json2numpy
            the connectivity graph contains numpy arrays interactions-0, interactions-1 etc.
            interactions-0 is between frag1 and frag2, interactions-1 between frag2 and frag3, etc.
            These Numpy arrays are connections A->B where A and B describe ATTRACT ranks *counting from zero*

Copyright 2015-2017 Sjoerd de Vries, Isaure Chauvot de Beauchene, TUM
"""

import sys, json
import numpy as np
from math import log
import sys
from collections import OrderedDict

def write_chain(ranks):
    '''  write the chain in output file'''
    global count
    #for i in ranks: print(i+1, end=' ')
    #print()
    count += 1

def walk(interactions_dict, pos, curr, ranks):
    '''
    Do the chain building, iteratively.
      pos = position of fragment in the chain
      curr = pose rank in the pool for the considered fragment
      ranks = which pose rank taken for each of the upstream fragments
    '''
    new_ranks = ranks + (curr,)
    if pos == nfrag - 1: # if we reached the end of the chain
        write_chain(new_ranks)
        return
    for target in interactions_dict[pos][curr]:
        # take the next connected pose to the current pose
        walk(interactions_dict, pos+1, target, new_ranks)

if __name__ == "__main__":
    # The npz file contains the connectivity graph
    # This is the output either of connect.py|json2numpy.py,
    # or of meanrank_filter.py applied to the output of connect.py.
    # It contains the list of connected poses
    # for each pair of consecutive fragments
    tree = np.load(sys.argv[1])

    # Nb of fragments in the chain
    nfrag = tree["nfrags"]

    # for each frag, interactions = list of the connected downstream poses
    # extracted from the tree
    interactions = [ tree["interactions-%i"%i] for i in range(nfrag-1)]
    interactions_dict = [OrderedDict() for l in range(nfrag-1)]
    for cnr, tinter in enumerate(interactions):
        inter_dict = interactions_dict[cnr]
        for source, target in tinter:
            #(source, target) is a pair of connected poses.
            # Store the connections with the next fragment.
            # Count number of connections with previous fragment.
            if source not in inter_dict: inter_dict[source] = []
            inter_dict[source].append(target)

    count = 0 # count number of chains
    for ff in interactions_dict[0]:
        walk(interactions_dict, 0, ff, ())

    print(count, file=sys.stderr)
